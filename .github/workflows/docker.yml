name: Create and Publish a Docker Image

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  REGISTRY: ghcr.io

jobs:
  build-and-push-image:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    outputs:
      version: ${{ steps.set-version.outputs.version }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: "recursive"

      - name: Install nix
        uses: nixbuild/nix-quick-install-action@v30
        with:
          nix_conf: |
            keep-env-derivations = true
            keep-outputs = true

      - name: Restore and save Nix store
        uses: nix-community/cache-nix-action@v6
        with:
          primary-key: build-${{ runner.os }}-${{ hashFiles('**/*.nix', 'flake.lock') }}
          restore-prefixes-first-match: build-${{ runner.os }}-

      - name: Set IMAGE_NAME
        run: echo "IMAGE_NAME=${GITHUB_REPOSITORY,,}" >> $GITHUB_ENV

      - name: Set VERSION
        id: set-version
        run: |
          VERSION=$(grep '^version' Cargo.toml | cut -d'"' -f2)
          echo "VERSION=${VERSION}" >> $GITHUB_ENV
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

      - name: Login to the Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Version and Build/Push Images
        env:
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
        run: |
          IMG_NAME="${REGISTRY}/${IMAGE_NAME}"

          echo "Building ${IMG_NAME}:${VERSION}"
          nix build '.?submodules=1#image'
          docker load <./result

          echo "Publish '${VERSION}'"
          docker tag "cangrebot:${VERSION}" "${IMG_NAME}:${VERSION}"
          docker push "${IMG_NAME}:${VERSION}"

          echo "Publish 'latest'"
          docker tag "cangrebot:${VERSION}" "${IMG_NAME}:latest"
          docker push "${IMG_NAME}:latest"

  update-remote:
    needs: [build-and-push-image]
    runs-on: ubuntu-latest
    env:
      VERSION: ${{ needs.build-and-push-image.outputs.version }}
    steps:
      - name: Install Kubectl
        run: |
          bash <(curl -sL https://raw.githubusercontent.com/RustLangES/workflows/main/setup-kubectl.sh) -t "${{ secrets.KUBE_TOKEN }}" -c "${{ secrets.KUBE_CERTIFICATE }}" -h "${{ secrets.KUBE_HOST }}"

      - name: Set ENV
        run: |
          NAMESPACE=$(echo "${{ github.repository }}" | cut -d'/' -f2)
          echo "NAMESPACE=$NAMESPACE" >> $GITHUB_ENV
          echo "IMAGE_NAME=${GITHUB_REPOSITORY,,}" >> $GITHUB_ENV

      - name: Update Remote Secrets
        run: |
          DISCORD_TOKEN=$(echo -n "${{ secrets.DISCORD_TOKEN }}" | base64 -w 0)
          GUILD_ID=$(echo -n "${{ secrets.GUILD_ID }}" | base64 -w 0)
          CHANNEL_DAILY=$(echo -n "${{ secrets.CHANNEL_DAILY }}" | base64 -w 0)
          CHANNEL_SUGGEST=$(echo -n "${{ secrets.CHANNEL_SUGGEST }}" | base64 -w 0)
          TEMPORAL_WAIT=$(echo -n "${{ secrets.CANGREBOT_TEMP_WAIT_CHANNEL }}" | base64 -w 0)
          TEMPORAL_CATEGORY=$(echo -n "${{ secrets.CANGREBOT_TEMP_CATEGORY }}" | base64 -w 0)
          TEMPORAL_LOGS=$(echo -n "${{ secrets.CANGREBOT_TEMP_LOGS_CHANNEL }}" | base64 -w 0)
          BOT_APIKEY=$(echo -n "${{ secrets.CANGREBOT_APIKEY }}" | base64 -w 0)
          GEMINI_KEY=$(echo -n "${{ secrets.CANGREBOT_GEMINI_KEY }}" | base64 -w 0)

          cat <<EOF > patch.json
          {
            "data": {
              "DISCORD_TOKEN": "$DISCORD_TOKEN",
              "GUILD_ID": "$GUILD_ID",
              "CHANNEL_DAILY": "$CHANNEL_DAILY",
              "CHANNEL_SUGGEST": "$CHANNEL_SUGGEST",
              "TEMPORAL_WAIT": "$TEMPORAL_WAIT",
              "TEMPORAL_CATEGORY": "$TEMPORAL_CATEGORY",
              "TEMPORAL_LOGS": "$TEMPORAL_LOGS",
              "BOT_APIKEY": "$BOT_APIKEY",
              "GEMINI_KEY": "$GEMINI_KEY"
            }
          }
          EOF

          kubectl patch secret "${{ env.NAMESPACE }}-secrets" \
            --namespace="${{ env.NAMESPACE }}" \
            --type=merge \
            --patch-file=patch.json

      - name: Update Remote Image
        run: |
          kubectl set image "deployment/${{ env.NAMESPACE }}" \
            bot="ghcr.io/${{ env.IMAGE_NAME }}:${{ env.VERSION }}" \
            -n "${{ env.NAMESPACE }}"
